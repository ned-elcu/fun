<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chroma Tool v4.4 (Eyedropper) — Redesigned</title>

  <!-- Tailwind Play CDN with theme tweak -->
  <script>
    window.tailwind = window.tailwind || {};
    window.tailwind.config = {
      theme: {
        extend: {
          colors: {
            chromaBg: '#0f1013',      /* main page bg */
            chromaPanel: '#14141a',   /* panels / cards */
            chromaText: '#e6eef8',
            chromaAccent: '#ff006e',
            chromaBorder: '#2b2b33',
            chromaInput: '#0b0b0e'
          },
          boxShadow: {
            'glow-lg': '0 10px 30px rgba(0,0,0,0.6), 0 2px 8px rgba(255,0,110,0.06)'
          },
          fontFamily: {
            ui: ['Inter', 'system-ui', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial']
          }
        }
      }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Required libs (must remain) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <style>
    /* Small compatibility / necessary bits that Tailwind utilities don't cover easily */
    :root {
      --accent: #ff006e;
    }

    /* Ensure existing class hooks used by JS still behave as expected */
    .img-preview img { pointer-events: none; object-fit: contain; max-width: 100%; max-height: 100%; }
    .img-preview.picking-mode { cursor: crosshair; outline: 2px dashed rgba(255,0,110,0.18); }
    .processing .processing-overlay { display:flex !important; }
    .processing-overlay { display:none; }

    /* Eyedropper icon kept as data URI for compatibility with generated menu */
    .eyedropper-icon {
      width: 14px; height: 14px;
      background: url('data:image/svg+xml;utf8,<svg fill="white" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.66 11.2C17.43 10.9 17.15 10.64 16.89 10.38L13.62 7.11C13.36 6.85 13.1 6.57 12.8 6.34L14.07 5.07L12.03 3.03C11.77 2.77 11.36 2.77 11.1 3.03L3 11.13C2.73 11.39 2.73 11.81 3 12.07L5.03 14.11L3.92 15.22C3.38 15.77 3.38 16.65 3.92 17.2L6.8 20.08C7.35 20.63 8.23 20.63 8.78 20.08L9.89 18.97L11.93 21C12.19 21.27 12.61 21.27 12.87 21L20.97 12.9L17.66 11.2ZM8.07 19.37L5.2 16.5L6.31 15.39L9.18 18.26L8.07 19.37ZM12.16 18.8L7.9 14.54L13.84 8.6L18.1 12.86L12.16 18.8Z"/></svg>') no-repeat center center;
      background-size: contain;
      display:inline-block;
    }

    /* Toast animations */
    @keyframes toast-in {
      from { transform: translateY(12px) scale(.98); opacity: 0; }
      to   { transform: translateY(0) scale(1); opacity: 1; }
    }
    @keyframes toast-out {
      from { transform: translateY(0) scale(1); opacity: 1; }
      to   { transform: translateY(12px) scale(.98); opacity: 0; }
    }

    /* Small visual polish for popover-menu created by JS (positioning preserved) */
    .popover-menu { min-width: 160px; z-index: 60; }

    /* Ensure hidden file input is still not focusable */
    input[type="file"][style*="display: none;"] { position: absolute; left: -9999px; }
  </style>
</head>
<body class="bg-chromaBg text-chromaText font-ui antialiased">

  <!-- Header -->
  <header class="w-full border-b border-chromaBorder/50">
    <div class="max-w-6xl mx-auto px-4 py-6 flex items-center gap-4">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-md bg-gradient-to-br from-pink-500 to-rose-600 flex items-center justify-center shadow-lg">
          <svg class="w-6 h-6 text-white" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 17v4h4l11-11-4-4L3 17z" fill="currentColor"/></svg>
        </div>
        <div>
          <h1 class="text-2xl font-semibold leading-tight">Chroma Tool <span class="text-sm text-chromaBorder/70 font-light">v4.4 (Eyedropper)</span></h1>
          <p class="text-xs text-chromaBorder/60 mt-0.5">Quick background removal — modern UI redesign (Tailwind)</p>
        </div>
      </div>

      <div class="ml-auto flex items-center gap-3">
        <div id="statusText" class="text-sm text-chromaBorder/60">0 images loaded</div>
        <button id="downloadBatchBtn" class="btn inline-flex items-center gap-2 bg-chromaAccent hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed text-white px-3 py-2 rounded-md text-xs font-semibold" disabled>
          Download All (Files)
        </button>
        <button id="downloadZipBtn" class="btn inline-flex items-center gap-2 bg-neutral-800 hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed text-white px-3 py-2 rounded-md text-xs font-semibold" disabled>
          Download All (ZIP)
        </button>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-8 grid grid-cols-1 lg:grid-cols-[340px_1fr] gap-6">

    <!-- Controls panel (keep same IDs & inputs) -->
    <aside class="sticky top-6 self-start">
      <div class="bg-chromaPanel/95 rounded-2xl p-5 shadow-glow-lg border border-chromaBorder">
        <!-- Dropzone -->
        <label id="dropzone" for="fileInput" class="dropzone group flex flex-col items-center justify-center gap-3 border-2 border-dashed border-chromaBorder rounded-lg p-5 cursor-pointer transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-chromaPanel focus-visible:ring-chromaAccent" aria-describedby="dropzone-desc">
          <svg class="w-9 h-9 text-chromaBorder/60 group-hover:text-chromaAccent transition-colors" viewBox="0 0 24 24" fill="none"><path d="M12 3v10" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 13l7-7 7 7" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <div class="text-sm text-chromaBorder/70">Drag & Drop images here — or click to browse</div>
          <div id="dropzone-desc" class="text-[11px] text-chromaBorder/50">Supports multi-image selection · PNG / JPG</div>
          <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
        </label>

        <div class="mt-5 space-y-4">

          <div>
            <label for="exportSize" class="block text-xs text-chromaBorder/60 mb-2">Export Size</label>
            <select id="exportSize" class="w-full rounded-md bg-chromaInput border border-chromaBorder text-sm px-3 py-2 focus:outline-none focus:ring-2 focus:ring-chromaAccent">
              <option value="512">512 x 512</option>
              <option value="256">256 x 256</option>
              <option value="128">128 x 128</option>
              <option value="64">64 x 64</option>
              <option value="original">Original (Disable Norm)</option>
            </select>
          </div>

          <div class="flex items-center justify-between bg-chromaInput border border-chromaBorder rounded-md px-3 py-2">
            <div>
              <label for="normalizeObject" class="text-sm text-chromaBorder/70 cursor-pointer">Normalize / Center Object</label>
            </div>
            <div>
              <input id="normalizeObject" type="checkbox" checked class="h-5 w-5 rounded-md accent-chromaAccent"/>
            </div>
          </div>

          <div>
            <label for="tolerance" class="block text-xs text-chromaBorder/60 mb-2">Tolerance <span id="tolVal" class="text-chromaAccent font-semibold">50</span></label>
            <input id="tolerance" type="range" min="1" max="150" value="50" class="w-full h-2 accent-chromaAccent">
          </div>

          <hr class="border-chromaBorder/40 my-2">

          <div>
            <label for="strokeWidth" class="block text-xs text-chromaBorder/60 mb-2">Stroke Width (px) <span id="strokeVal" class="text-chromaAccent font-semibold">10</span></label>
            <input id="strokeWidth" type="range" min="0" max="50" value="10" class="w-full h-2 accent-chromaAccent">
          </div>

          <div>
            <label for="strokeColor" class="block text-xs text-chromaBorder/60 mb-2">Stroke Color</label>
            <input id="strokeColor" type="color" value="#000000" class="w-full h-10 p-0 border-0 rounded-md">
          </div>

          <div class="pt-2">
            <button id="downloadZipBtn_alt" class="w-full text-xs py-2 rounded-md bg-neutral-700 hover:bg-neutral-650 text-white hidden">Alternate</button>
          </div>

        </div>
      </div>
    </aside>

    <!-- Results / Grid -->
    <section class="min-h-[60vh]">
      <div class="bg-transparent mb-4 flex items-center justify-between">
        <div class="text-sm text-chromaBorder/60">Processed results</div>
        <div class="flex items-center gap-3">
          <!-- These buttons are duplicates visually to header but the original IDs MUST remain on the header top — keep header ones as primary -->
        </div>
      </div>

      <div id="resultsGrid" class="grid gap-4 grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 auto-rows-fr">
        <!-- JS will append .image-card elements here (keeps same class names / structure) -->
      </div>

      <div class="mt-8 text-xs text-chromaBorder/50">Tip: Click a tag on a card to change the chroma (Green/Blue/White/Black) or use the Eyedropper to pick a custom background color.</div>
    </section>
  </main>

  <!-- Toast / Snackbar Container (UI + hook) -->
  <div id="toastContainer" aria-live="polite" aria-atomic="true" class="fixed z-50 right-6 bottom-6 flex flex-col gap-3 max-w-xs sm:max-w-sm"></div>

  <!-- IMPORTANT: The application core JS must remain unchanged. Below is the original app logic (kept intact) -->
<script>
    // --- State ---
    const state = {
        files: [], 
        settings: { 
            tolerance: 50, 
            strokeWidth: 10, 
            strokeColor: '#000000',
            exportSize: '512',
            normalizeObject: true 
        },
        activeMenuFileId: null
    };

    const els = {
        dropzone: document.getElementById('dropzone'),
        fileInput: document.getElementById('fileInput'),
        exportSize: document.getElementById('exportSize'),
        normalizeObject: document.getElementById('normalizeObject'),
        tolerance: document.getElementById('tolerance'),
        strokeWidth: document.getElementById('strokeWidth'),
        strokeColor: document.getElementById('strokeColor'),
        tolVal: document.getElementById('tolVal'),
        strokeVal: document.getElementById('strokeVal'),
        resultsGrid: document.getElementById('resultsGrid'),
        downloadZipBtn: document.getElementById('downloadZipBtn'),
        downloadBatchBtn: document.getElementById('downloadBatchBtn'),
        statusText: document.getElementById('statusText')
    };

    let processTimeout;

    // --- Init ---
    window.addEventListener('DOMContentLoaded', () => {
        loadSettings();
        bindEvents();
    });

    window.addEventListener('click', (e) => {
        if (!e.target.closest('.tag') && !e.target.closest('.popover-menu')) {
            closeAllMenus();
        }
    });

    function closeAllMenus() {
        document.querySelectorAll('.popover-menu').forEach(el => el.classList.remove('active'));
        state.activeMenuFileId = null;
    }

    function loadSettings() {
        const saved = localStorage.getItem('chromaToolSettings_v4.4');
        if (saved) {
            state.settings = { ...state.settings, ...JSON.parse(saved) };
            els.tolerance.value = state.settings.tolerance;
            els.strokeWidth.value = state.settings.strokeWidth;
            els.strokeColor.value = state.settings.strokeColor;
            els.exportSize.value = state.settings.exportSize;
            els.normalizeObject.checked = state.settings.normalizeObject;
            els.tolVal.innerText = state.settings.tolerance;
            els.strokeVal.innerText = state.settings.strokeWidth;
        }
    }

    function saveSettings() {
        localStorage.setItem('chromaToolSettings_v4.4', JSON.stringify(state.settings));
    }

    function bindEvents() {
        els.dropzone.addEventListener('click', () => els.fileInput.click());
        els.dropzone.addEventListener('dragover', (e) => { e.preventDefault(); els.dropzone.classList.add('dragover'); });
        els.dropzone.addEventListener('dragleave', () => els.dropzone.classList.remove('dragover'));
        els.dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            els.dropzone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        els.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        const updateHandler = () => {
            state.settings.tolerance = parseInt(els.tolerance.value);
            state.settings.strokeWidth = parseInt(els.strokeWidth.value);
            state.settings.strokeColor = els.strokeColor.value;
            state.settings.exportSize = els.exportSize.value;
            state.settings.normalizeObject = els.normalizeObject.checked;
            
            els.tolVal.innerText = state.settings.tolerance;
            els.strokeVal.innerText = state.settings.strokeWidth;
            
            saveSettings();
            triggerBatchProcess();
        };

        els.tolerance.addEventListener('input', updateHandler);
        els.strokeWidth.addEventListener('input', updateHandler);
        els.strokeColor.addEventListener('input', updateHandler);
        els.exportSize.addEventListener('change', updateHandler);
        els.normalizeObject.addEventListener('change', updateHandler); 

        els.downloadZipBtn.addEventListener('click', downloadAllZip);
        els.downloadBatchBtn.addEventListener('click', downloadAllBatch);
    }

    function handleFiles(fileList) {
        Array.from(fileList).forEach(file => {
            if (!file.type.startsWith('image/')) return;
            const id = Date.now() + Math.random().toString(36).substr(2, 9);
            const card = createResultCard(id, file.name);
            els.resultsGrid.appendChild(card);

            const fileData = { 
                id, 
                originalFile: file, 
                processedBlob: null, 
                element: card,
                manualMode: null, 
                customHex: '#ff0000'
            };

            const tag = card.querySelector('.tag');
            tag.addEventListener('click', (e) => toggleMenu(e, fileData));

            state.files.push(fileData);
            processImage(fileData);
        });
        updateStatus();
    }

    function updateStatus() {
        els.statusText.innerText = `${state.files.length} image(s)`;
        const isDisabled = state.files.length === 0;
        els.downloadZipBtn.disabled = isDisabled;
        els.downloadBatchBtn.disabled = isDisabled;
    }

    function triggerBatchProcess() {
        clearTimeout(processTimeout);
        processTimeout = setTimeout(() => {
            state.files.forEach(processImage);
        }, 300);
    }

    function toggleMenu(e, fileData) {
        e.stopPropagation();
        const existingMenu = fileData.element.querySelector('.popover-menu');
        
        if (existingMenu.classList.contains('active')) {
            existingMenu.classList.remove('active');
            state.activeMenuFileId = null;
            return;
        }
        closeAllMenus();

        // Menu with Eyedropper
        existingMenu.innerHTML = `
            <div class="popover-item" data-mode="green"><div class="color-dot" style="background:#0f0"></div> Green</div>
            <div class="popover-item" data-mode="blue"><div class="color-dot" style="background:#00f"></div> Blue</div>
            <div class="popover-item" data-mode="white"><div class="color-dot" style="background:#fff"></div> White</div>
            <div class="popover-item" data-mode="black"><div class="color-dot" style="background:#000"></div> Black</div>
            <div class="popover-item" data-mode="picker"><div class="eyedropper-icon"></div> Eyedropper</div>
        `;

        existingMenu.querySelectorAll('.popover-item').forEach(item => {
            item.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const mode = item.dataset.mode;
                
                if (mode === 'picker') {
                    activateEyedropper(fileData);
                    closeAllMenus();
                } else {
                    fileData.manualMode = mode;
                    closeAllMenus();
                    processImage(fileData);
                }
            });
        });

        existingMenu.classList.add('active');
        state.activeMenuFileId = fileData.id;
    }

    // --- Eyedropper Logic ---
    function activateEyedropper(fileData) {
        const previewDiv = fileData.element.querySelector('.img-preview');
        const imgEl = previewDiv.querySelector('img');

        // 1. Temporarily revert to ORIGINAL image so user can see background
        imgEl.src = URL.createObjectURL(fileData.originalFile);
        
        // 2. Set UI State
        previewDiv.classList.add('picking-mode');

        // 3. One-time Click Listener
        const clickHandler = (e) => {
            e.preventDefault();
            e.stopPropagation(); // prevent opening file dialog if bubbling
            
            // Cleanup UI
            previewDiv.classList.remove('picking-mode');
            
            // Calculate pixel position
            const rect = imgEl.getBoundingClientRect();
            
            // Check if click is actually on the image (due to object-fit: contain)
            // But since we use object-fit:contain, the img element spans the full div usually.
            // We need to draw the image to a canvas to read pixel data.
            
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // Math to map DOM click (x,y) to Image (naturalX, naturalY)
                // This is tricky with object-fit: contain.
                // Simplified approach: Calculate Aspect Ratios
                
                const containerRatio = rect.width / rect.height;
                const imgRatio = img.width / img.height;
                
                let renderWidth, renderHeight, renderLeft, renderTop;

                if (imgRatio > containerRatio) {
                    // Image constrained by width
                    renderWidth = rect.width;
                    renderHeight = rect.width / imgRatio;
                    renderLeft = 0;
                    renderTop = (rect.height - renderHeight) / 2;
                } else {
                    // Image constrained by height
                    renderHeight = rect.height;
                    renderWidth = rect.height * imgRatio;
                    renderTop = 0;
                    renderLeft = (rect.width - renderWidth) / 2;
                }

                // Click coordinates relative to the image rendering box
                const clientX = e.clientX - rect.left;
                const clientY = e.clientY - rect.top;

                const relativeX = clientX - renderLeft;
                const relativeY = clientY - renderTop;

                // Check bounds (did they click black bars?)
                if (relativeX >= 0 && relativeX <= renderWidth && relativeY >= 0 && relativeY <= renderHeight) {
                    const trueX = Math.floor((relativeX / renderWidth) * img.width);
                    const trueY = Math.floor((relativeY / renderHeight) * img.height);
                    
                    const p = ctx.getImageData(trueX, trueY, 1, 1).data;
                    const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                    
                    // Apply Selection
                    fileData.manualMode = 'custom';
                    fileData.customHex = hex;
                    
                    // Reprocess
                    processImage(fileData);
                } else {
                    // User clicked the padding/black bars - Cancel or Reprocess original
                    processImage(fileData);
                }
            };
            img.src = URL.createObjectURL(fileData.originalFile);
        };

        // Add listener to the DIV container, not the IMG (because img has pointer-events:none)
        previewDiv.addEventListener('click', clickHandler, { once: true });
    }

    // --- Core Processing ---

    function processImage(fileData) {
        const card = fileData.element;
        card.classList.add('processing');

        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');

            ctx.drawImage(img, 0, 0);
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            // 1. DETERMINE MODE
            let mode = 'green';
            let customRGB = null;

            if (fileData.manualMode) {
                mode = fileData.manualMode;
                if (mode === 'custom' && fileData.customHex) {
                    const r = parseInt(fileData.customHex.substr(1,2), 16);
                    const g = parseInt(fileData.customHex.substr(3,2), 16);
                    const b = parseInt(fileData.customHex.substr(5,2), 16);
                    customRGB = { r, g, b };
                }
            } else {
                // Auto Detection
                let gScore = 0, bScore = 0, blackScore = 0, whiteScore = 0;
                for (let i = 0; i < data.length; i+=32) { 
                    if (i < width*4 || i > (height-1)*width*4 || i % (width*4) === 0) {
                        const r = data[i], g = data[i+1], b = data[i+2];
                        const bright = (r+g+b)/3;
                        if (bright < 40) blackScore++; 
                        else if (bright > 230) whiteScore++; 
                        else if (g > r && g > b) gScore++; 
                        else if (b > r && b > g) bScore++; 
                    }
                }
                let maxScore = Math.max(gScore, bScore, blackScore, whiteScore);
                if (maxScore === bScore) mode = 'blue';
                else if (maxScore === blackScore) mode = 'black';
                else if (maxScore === whiteScore) mode = 'white';
            }

            // Update UI Tag
            const tag = card.querySelector('.tag');
            if (mode === 'custom' && customRGB) {
                tag.innerText = 'Custom';
                tag.style.background = fileData.customHex;
                const yiq = ((customRGB.r*299)+(customRGB.g*587)+(customRGB.b*114))/1000;
                tag.style.color = (yiq >= 128) ? 'black' : 'white';
            } else {
                tag.innerText = mode;
                tag.style.background = (mode === 'green') ? '#90EE90' : (mode === 'blue') ? '#ADD8E6' : (mode === 'white') ? '#eee' : '#222';
                tag.style.color = (mode === 'white' || mode === 'green' || mode === 'blue') ? '#000' : '#fff';
            }

            // 2. REMOVE BACKGROUND
            const tol = state.settings.tolerance;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                let isBackground = false;

                if (mode === 'green') { 
                    if (g > r + tol && g > b + tol) isBackground = true; 
                } 
                else if (mode === 'blue') { 
                    if (b > r + tol && b > g + tol) isBackground = true; 
                }
                else if (mode === 'black') { 
                    if (r < tol && g < tol && b < tol) isBackground = true; 
                }
                else if (mode === 'white') { 
                    if (r > (255-tol) && g > (255-tol) && b > (255-tol)) isBackground = true; 
                }
                else if (mode === 'custom' && customRGB) {
                    // Euclidean distance for custom color
                    const dist = Math.sqrt(
                        Math.pow(r - customRGB.r, 2) + 
                        Math.pow(g - customRGB.g, 2) + 
                        Math.pow(b - customRGB.b, 2)
                    );
                    // Standardize tolerance logic for custom pick
                    if (dist < tol * 1.5) isBackground = true; 
                }

                if (isBackground) data[i+3] = 0; 
            }

            // 3. CLEAN UP
            removeIslands(data, width, height, 100);

            // 4. STROKE
            if (state.settings.strokeWidth > 0) {
                applyStroke(data, width, height, state.settings.strokeWidth, state.settings.strokeColor);
            }

            ctx.putImageData(imageData, 0, 0);

            // 5. RESIZE / NORMALIZE
            let finalCanvas = document.createElement('canvas');
            let exportSize = parseInt(state.settings.exportSize);
            
            if (isNaN(exportSize)) exportSize = Math.max(width, height); 
            
            finalCanvas.width = exportSize;
            finalCanvas.height = exportSize;
            const fCtx = finalCanvas.getContext('2d');
            fCtx.imageSmoothingEnabled = true;
            fCtx.imageSmoothingQuality = 'high';

            if (state.settings.normalizeObject) {
                const bounds = getContentBounds(data, width, height);
                
                if (bounds.w > 0 && bounds.h > 0) {
                    const padding = exportSize * 0.1; 
                    const availableW = exportSize - (padding * 2);
                    const availableH = exportSize - (padding * 2);
                    const scale = Math.min(availableW / bounds.w, availableH / bounds.h);
                    
                    const renderW = bounds.w * scale;
                    const renderH = bounds.h * scale;
                    const renderX = (exportSize - renderW) / 2;
                    const renderY = (exportSize - renderH) / 2;

                    fCtx.drawImage(
                        canvas, 
                        bounds.x, bounds.y, bounds.w, bounds.h, 
                        renderX, renderY, renderW, renderH      
                    );
                } else {
                    fCtx.clearRect(0,0, exportSize, exportSize);
                }
            } else {
                if (state.settings.exportSize === 'original') {
                    finalCanvas = canvas; 
                } else {
                    fCtx.drawImage(canvas, 0, 0, exportSize, exportSize);
                }
            }

            // 6. FINALIZE
            finalCanvas.toBlob((blob) => {
                fileData.processedBlob = blob;
                const url = URL.createObjectURL(blob);
                const prevContainer = card.querySelector('.img-preview');
                prevContainer.innerHTML = '';
                const resImg = new Image();
                resImg.src = url;
                prevContainer.appendChild(resImg);

                card.querySelector('.dl-btn').onclick = () => {
                    saveAs(blob, 'processed_' + fileData.originalFile.name.replace(/\.[^/.]+$/, "") + ".png");
                };
                card.classList.remove('processing');
            }, 'image/png');
        };
        img.src = URL.createObjectURL(fileData.originalFile);
    }

    // --- Helpers ---

    function getContentBounds(data, w, h) {
        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const alpha = data[(y * w + x) * 4 + 3];
                if (alpha > 0) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return { x:0, y:0, w:0, h:0 };
        return { x: minX, y: minY, w: (maxX - minX + 1), h: (maxY - minY + 1) };
    }

    function removeIslands(data, width, height, minSize) {
        const visited = new Uint8Array(width * height);
        const stack = [];
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                if (data[idx * 4 + 3] > 0 && visited[idx] === 0) {
                    stack.push(idx);
                    visited[idx] = 1;
                    const component = [idx];
                    while(stack.length > 0) {
                        const curr = stack.pop();
                        const neighbors = [1, -1, width, -width];
                        for (let offset of neighbors) {
                             const nIdx = curr + offset;
                             if (nIdx >= 0 && nIdx < width*height && visited[nIdx]===0) {
                                 if (data[nIdx*4+3] > 0) {
                                     visited[nIdx] = 1;
                                     stack.push(nIdx);
                                     component.push(nIdx);
                                 }
                             }
                        }
                    }
                    if (component.length < minSize) {
                        for (const i of component) data[i * 4 + 3] = 0;
                    }
                }
            }
        }
    }

    function applyStroke(data, width, height, strokeWidth, hexColor) {
        const INF = 1e9;
        const grid = new Float32Array(width * height);
        const sr = parseInt(hexColor.substr(1,2), 16);
        const sg = parseInt(hexColor.substr(3,2), 16);
        const sb = parseInt(hexColor.substr(5,2), 16);

        for (let i = 0; i < width * height; i++) grid[i] = (data[i * 4 + 3] > 0) ? 0 : INF;
        for (let i = 0; i < width*height; i++) {
            if (grid[i] > 0) {
                const x = i % width;
                const y = Math.floor(i / width);
                let minD = grid[i];
                if (x > 0) minD = Math.min(minD, grid[i-1] + 1);
                if (y > 0) minD = Math.min(minD, grid[i-width] + 1);
                if (x > 0 && y > 0) minD = Math.min(minD, grid[i-width-1] + 1.414);
                if (x < width-1 && y > 0) minD = Math.min(minD, grid[i-width+1] + 1.414);
                grid[i] = minD;
            }
        }
        for (let i = width*height - 1; i >= 0; i--) {
            if (grid[i] > 0) {
                const x = i % width;
                const y = Math.floor(i / width);
                let minD = grid[i];
                if (x < width - 1) minD = Math.min(minD, grid[i+1] + 1);
                if (y < height - 1) minD = Math.min(minD, grid[i+width] + 1);
                if (x < width - 1 && y < height - 1) minD = Math.min(minD, grid[i+width+1] + 1.414);
                if (x > 0 && y < height - 1) minD = Math.min(minD, grid[i+width-1] + 1.414);
                grid[i] = minD;
            }
        }
        for (let i = 0; i < width * height; i++) {
            const dist = grid[i];
            if (dist > 0 && dist <= strokeWidth + 0.5) {
                const pIdx = i * 4;
                let alpha = 255;
                if (dist > strokeWidth - 0.5) alpha = 255 * (1 - (dist - (strokeWidth - 0.5)));
                data[pIdx] = sr; data[pIdx+1] = sg; data[pIdx+2] = sb; data[pIdx+3] = alpha;
            }
        }
    }

    function createResultCard(id, filename) {
        const div = document.createElement('div');
        div.className = 'image-card bg-chromaPanel rounded-2xl overflow-hidden shadow-sm border border-chromaBorder flex flex-col';
        div.innerHTML = `
            <div class="img-preview bg-[conic-gradient(at_20%_20%,rgba(0,0,0,0.02),transparent)] h-44 flex items-center justify-center p-2">
              <div style="color: #555">Waiting...</div>
            </div>
            <div class="processing-overlay absolute inset-0 bg-black/60 hidden items-center justify-center text-white text-sm">Processing...</div>
            <div class="card-actions flex items-center justify-between px-3 py-2 bg-transparent border-t border-chromaBorder">
                <div class="flex items-center gap-3 min-w-0">
                    <span class="tag bg-neutral-700 text-xs px-2 py-1 rounded cursor-pointer select-none" title="Click to change chroma key">...</span>
                    <div class="popover-menu hidden absolute mt-2 right-3"></div>
                    <div class="text-sm truncate text-chromaBorder/50">${filename}</div>
                </div>
                <button class="icon-btn dl-btn text-chromaBorder/60 hover:text-chromaText" title="Download">⬇</button>
            </div>
        `;
        return div;
    }

    function downloadAllZip() {
        const zip = new JSZip();
        const imgFolder = zip.folder("processed_images");
        let count = 0;
        state.files.forEach(file => {
            if (file.processedBlob) {
                imgFolder.file('processed_' + file.originalFile.name.replace(/\.[^/.]+$/, "") + ".png", file.processedBlob);
                count++;
            }
        });
        if (count > 0) {
            els.downloadZipBtn.disabled = true; 
            imgFolder.generateAsync({type:"blob"}).then(content => {
                saveAs(content, "chroma_key_results.zip");
                els.downloadZipBtn.disabled = false; 
            });
        }
    }

    function downloadAllBatch() {
        let downloadedCount = 0;
        els.downloadBatchBtn.disabled = true; 
        const total = state.files.filter(f => f.processedBlob).length;
        if(total === 0) { els.downloadBatchBtn.disabled = false; return; }

        state.files.forEach((file, index) => {
            if (file.processedBlob) {
                setTimeout(() => {
                    saveAs(file.processedBlob, 'processed_' + file.originalFile.name.replace(/\.[^/.]+$/, "") + ".png");
                    downloadedCount++;
                    if (downloadedCount === total) els.downloadBatchBtn.disabled = false;
                }, index * 250); 
            }
        });
    }
</script>

<!-- Toast / Snackbar Implementation (UI only - non-intrusive, global hook) -->
<script>
  (function () {
    const container = document.getElementById('toastContainer');

    // Helper: is mobile viewport (for center vs corner placement)
    function isMobile() {
      return window.matchMedia && window.matchMedia('(max-width: 640px)').matches;
    }

    function placeContainer() {
      if (isMobile()) {
        container.style.right = '0';
        container.style.left = '50%';
        container.style.transform = 'translateX(-50%)';
        container.style.bottom = '18px';
      } else {
        container.style.right = '24px';
        container.style.left = 'auto';
        container.style.transform = 'none';
        container.style.bottom = '24px';
      }
    }
    window.addEventListener('resize', placeContainer);
    placeContainer();

    /**
     * showToast(type, message, options)
     * type: 'success' | 'error' | 'info' | 'warning' | 'progress'
     * message: string or DOM-friendly
     * options:
     *   - duration (ms) default 4000 (progress toasts do not auto-dismiss)
     *   - action: { label: 'Undo', onClick: fn } (optional)
     * Returns an object { id, dismiss } so callers can close programmatically.
     */
    function showToast(type, message, options = {}) {
      const id = 't_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
      const dur = options.duration ?? 4000;
      const role = (type === 'error' || type === 'warning') ? 'alert' : 'status';

      // Create toast node
      const t = document.createElement('div');
      t.setAttribute('role', role);
      t.setAttribute('aria-live', 'polite');
      t.id = id;
      t.className = 'max-w-full sm:max-w-sm w-full flex items-start gap-3 p-3 rounded-lg shadow-md border border-chromaBorder/50';
      t.style.background = '#0b0b0e';
      t.style.color = '#e6eef8';
      t.style.animation = 'toast-in 220ms cubic-bezier(.2,.9,.3,1)';

      // Icon
      const icon = document.createElement('div');
      icon.className = 'flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-white';
      icon.style.background = (type === 'success') ? '#10b981' : (type === 'error') ? '#ef4444' : (type === 'warning') ? '#f59e0b' : (type === 'info') ? '#3b82f6' : '#6b7280';
      icon.innerHTML = (type === 'success') ? '✓' : (type === 'error') ? '!' : (type === 'warning') ? '!' : (type === 'info') ? 'i' : '…';

      // Content
      const content = document.createElement('div');
      content.className = 'flex-1 text-sm leading-snug';
      if (typeof message === 'string') content.innerText = message;
      else content.appendChild(message);

      // Actions
      const actions = document.createElement('div');
      actions.className = 'flex items-center gap-2';

      if (options.action && options.action.label) {
        const btn = document.createElement('button');
        btn.className = 'text-xs px-2 py-1 rounded-md border border-transparent hover:border-chromaAccent/40';
        btn.style.background = 'transparent';
        btn.style.color = 'var(--accent, #ff006e)';
        btn.innerText = options.action.label;
        btn.addEventListener('click', (ev) => {
          try { options.action.onClick && options.action.onClick(ev); } catch(e) { console.error(e); }
        });
        actions.appendChild(btn);
      }

      // Close button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'text-xs text-chromaBorder/60 hover:text-chromaText';
      closeBtn.innerText = '✕';
      closeBtn.title = 'Dismiss';
      closeBtn.addEventListener('click', () => dismiss());

      // Build
      t.appendChild(icon);
      t.appendChild(content);
      t.appendChild(actions);
      t.appendChild(closeBtn);

      // Progress toasts should show indicator
      let progressElem = null;
      if (type === 'progress') {
        progressElem = document.createElement('div');
        progressElem.className = 'w-full h-1 mt-2 rounded bg-neutral-700 overflow-hidden';
        const bar = document.createElement('div');
        bar.style.width = '0%';
        bar.style.height = '100%';
        bar.style.background = 'linear-gradient(90deg, rgba(255,0,110,0.9), rgba(255,100,150,0.9))';
        progressElem.appendChild(bar);
        content.appendChild(progressElem);
        // expose method to update progress with toastHandle.update(percent)
      }

      // Insert
      container.prepend(t);

      // Auto dismiss unless progress
      let autoTimer = null;
      if (type !== 'progress') {
        autoTimer = setTimeout(() => dismiss(), dur);
      }

      // Dismiss function
      function dismiss() {
        if (!t) return;
        t.style.animation = 'toast-out 180ms ease';
        setTimeout(() => {
          try { t.remove(); } catch(e) {}
        }, 180);
        if (autoTimer) { clearTimeout(autoTimer); autoTimer = null; }
      }

      // Return handle
      const handle = {
        id,
        dismiss,
        update: (opts = {}) => {
          if (opts.message) {
            if (typeof opts.message === 'string') content.innerText = opts.message;
            else { content.innerHTML = ''; content.appendChild(opts.message); }
          }
          if (opts.progress !== undefined && progressElem) {
            const bar = progressElem.firstElementChild;
            bar.style.width = Math.max(0, Math.min(100, opts.progress)) + '%';
          }
        }
      };

      return handle;
    }

    // Expose globally (non-conflicting name)
    window.showToast = showToast;

    // Example usage hooks for app: (left commented so it doesn't spam)
    // const t = showToast('info','Processing started',{ duration:2000 });
    // const p = showToast('progress','Uploading...', { duration: 0 });
    // setTimeout(()=> p.update({progress:40}), 500);

  })();
</script>

</body>
</html>
