<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chroma-key + Outside Stroke (Client-side)</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --muted:#9aa4b2; --accent:#06b6d4;
    --ui-bg:#0b1220; --glass: rgba(255,255,255,0.02);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:linear-gradient(180deg,#071026 0%, #071421 100%);color:#e6eef6;padding:18px;box-sizing:border-box;}
  .container{max-width:1100px;margin:0 auto;}
  header{display:flex;gap:16px;align-items:center;margin-bottom:18px;}
  h1{font-size:20px;margin:0}
  p.lead{margin:0;color:var(--muted);font-size:13px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;margin:14px 0;padding:12px;background:var(--glass);border-radius:10px}
  label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
  input[type=range]{width:220px}
  input[type=color]{height:36px;width:56px;border-radius:6px;border:none;padding:0}
  .dropzone{border:2px dashed rgba(255,255,255,0.06);padding:20px;border-radius:10px;text-align:center;cursor:pointer;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);}
  .dropzone.dragover{border-color:var(--accent);box-shadow:0 6px 24px rgba(3,105,161,0.12)}
  .grid{display:flex;flex-wrap:wrap;gap:12px;margin-top:14px}
  .card{width:160px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.5);display:flex;flex-direction:column;gap:8px;align-items:center}
  canvas.preview{background:transparent;border-radius:6px;image-rendering:pixelated;max-width:140px;max-height:140px}
  .btn{background:var(--accent);color:#052024;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .meta{font-size:12px;color:var(--muted);text-align:center}
  .actions{display:flex;gap:6px}
  .small{font-size:12px;padding:6px 8px;border-radius:8px}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .top-controls{display:flex;gap:8px;align-items:center}
  .flex-grow{flex:1}
  .download-all{margin-left:auto}
  .note{color:var(--muted);font-size:13px;margin-top:8px}
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Chroma-key + Photoshop-style Outside Stroke — Client-side</h1>
        <p class="lead">Auto-detect green/blue background. Batch upload, auto-process, adjustable stroke/tolerance, persistent settings.</p>
      </div>
    </header>

    <div class="controls" role="region" aria-label="Tool controls">
      <label>
        Tolerance <span id="tolVal" style="color:var(--accent);margin-left:8px">60</span>
        <input id="tolerance" type="range" min="0" max="255" value="60" />
      </label>

      <label>
        Stroke width <span id="strokeVal" style="color:var(--accent);margin-left:8px">10 px</span>
        <input id="strokeWidth" type="range" min="1" max="40" value="10" />
      </label>

      <label style="display:flex;align-items:center;gap:8px;">
        Stroke color
        <input id="strokeColor" type="color" value="#000000" />
      </label>

      <div style="display:flex;flex-direction:column;justify-content:center">
        <div class="row">
          <button id="clearAll" class="btn ghost small">Clear All</button>
          <button id="downloadZip" class="btn small download-all">Download All (ZIP)</button>
        </div>
        <div class="note">Settings persist across sessions (localStorage).</div>
      </div>
    </div>

    <div id="dropzone" class="dropzone" tabindex="0" role="button" aria-label="Drop images here to upload">
      <strong>Drop images here or click to select</strong>
      <div style="margin-top:8px;color:var(--muted)">Supports 256×256 and 512×512 icons. Multiple files possible. Files auto-process on upload.</div>
      <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
    </div>

    <div id="grid" class="grid" aria-live="polite" style="margin-top:12px"></div>

    <footer>
      <div>Algorithm: sample corners to choose green/blue key, pixel-distance thresholding for alpha, mask dilation for outside stroke. Best results with uniform studio green/blue.</div>
    </footer>
  </div>

<script>
// ---- Utilities & defaults ----
const LS_KEY = 'chromaStrokeSettings_v1';
const defaults = {
  tolerance: 60,
  strokeWidth: 10,
  strokeColor: '#000000'
};

function loadSettings(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return {...defaults};
    const parsed = JSON.parse(raw);
    return {...defaults, ...parsed};
  }catch(e){ return {...defaults}; }
}
function saveSettings(s){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(s)); }catch(e){}
}

// ---- DOM ----
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const grid = document.getElementById('grid');
const toleranceEl = document.getElementById('tolerance');
const tolVal = document.getElementById('tolVal');
const strokeWidthEl = document.getElementById('strokeWidth');
const strokeVal = document.getElementById('strokeVal');
const strokeColorEl = document.getElementById('strokeColor');
const clearAllBtn = document.getElementById('clearAll');
const downloadZipBtn = document.getElementById('downloadZip');

let STATE = {
  items: [] // {file, name, canvas, blob}
};

// apply saved settings
const SETTINGS = loadSettings();
toleranceEl.value = SETTINGS.tolerance;
tolVal.textContent = SETTINGS.tolerance;
strokeWidthEl.value = SETTINGS.strokeWidth;
strokeVal.textContent = `${SETTINGS.strokeWidth} px`;
strokeColorEl.value = SETTINGS.strokeColor;

// keep settings synced
[toleranceEl, strokeWidthEl, strokeColorEl].forEach(el=>{
  el.addEventListener('input', ()=> {
    SETTINGS.tolerance = Number(toleranceEl.value);
    SETTINGS.strokeWidth = Number(strokeWidthEl.value);
    SETTINGS.strokeColor = strokeColorEl.value;
    tolVal.textContent = SETTINGS.tolerance;
    strokeVal.textContent = `${SETTINGS.strokeWidth} px`;
    saveSettings(SETTINGS);
  });
});

// ---- dropzone behavior ----
dropzone.addEventListener('click', ()=> fileInput.click());
dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e=>{
  e.preventDefault(); dropzone.classList.remove('dragover');
  const files = Array.from(e.dataTransfer.files || []);
  handleFiles(files);
});
fileInput.addEventListener('change', ()=> handleFiles(Array.from(fileInput.files)));

// ---- File handling & processing ----
function handleFiles(files){
  if(!files.length) return;
  // filter images
  const imgs = files.filter(f=> f.type.startsWith('image/'));
  for(const file of imgs){
    processFile(file);
  }
}

async function processFile(file){
  const img = await loadImageFromFile(file);
  // create canvases
  const width = img.width;
  const height = img.height;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  // draw original
  ctx.drawImage(img,0,0,width,height);
  // process
  await applyChromaAndStroke(canvas, SETTINGS.tolerance, SETTINGS.strokeWidth, SETTINGS.strokeColor);
  // create blob for download
  canvas.toBlob(blob=>{
    const id = cryptoRandomId();
    const item = {id, file, name: file.name.replace(/\.[^.]+$/, '') + '.png', canvas, blob};
    STATE.items.push(item);
    renderItem(item);
  }, 'image/png');
}

// tiny id
function cryptoRandomId(){ return Math.random().toString(36).slice(2,9); }

// load Image
function loadImageFromFile(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
    img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
    img.src = url;
  });
}

// detect key color by sampling corners
function detectKeyColor(imageData, width, height){
  // sample 4 corners 8x8 blocks average
  const sample = (sx, sy, sw, sh) => {
    let r=0,g=0,b=0,c=0;
    const data = imageData;
    for(let y=sy;y<sy+sh;y++){
      for(let x=sx;x<sx+sw;x++){
        const i = (y*width + x)*4;
        r += data[i]; g+=data[i+1]; b+=data[i+2]; c++;
      }
    }
    return {r: r/c, g: g/c, b: b/c};
  };
  const size = Math.max(4, Math.floor(Math.min(width,height)/16));
  const corners = [
    sample(0,0,size,size),
    sample(width-size,0,size,size),
    sample(0,height-size,size,size),
    sample(width-size,height-size,size,size)
  ];
  // average corners
  let r=0,g=0,b=0;
  for(const c of corners){ r+=c.r; g+=c.g; b+=c.b; }
  r/=4; g/=4; b/=4;
  // decide green vs blue
  if(g > b + 12 && g > r + 12) return {r:0,g:255,b:0, label:'green'};
  if(b > g + 12 && b > r + 12) return {r:0,g:0,b:255, label:'blue'};
  // fallback: pick the dominant channel of averaged corners
  if(g >= b && g >= r) return {r:0,g:255,b:0, label:'green'};
  if(b >= g && b >= r) return {r:0,g:0,b:255, label:'blue'};
  return {r:0,g:255,b:0, label:'green'}; // default green
}

// core chroma + stroke
async function applyChromaAndStroke(canvas, tolerance, strokeWidth, strokeColor){
  const w = canvas.width, h = canvas.height;
  const ctx = canvas.getContext('2d');
  let imgData = ctx.getImageData(0,0,w,h);
  const data = imgData.data;
  // detect key color from current pixels
  const key = detectKeyColor(data, w, h);
  // build subject alpha mask
  const subjectMask = new Uint8ClampedArray(w*h); // 1 = subject
  // compute per-pixel transparency based on distance to key color
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = (y*w + x)*4;
      const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
      // color distance (euclidean)
      const dr = r - key.r, dg = g - key.g, db = b - key.b;
      const dist = Math.sqrt(dr*dr + dg*dg + db*db);
      if(dist <= tolerance){
        // background pixel: set alpha 0
        data[i+3] = 0;
        subjectMask[y*w + x] = 0;
      } else {
        subjectMask[y*w + x] = 1;
      }
    }
  }

  // OPTIONAL: simple despill - reduce green/blue spill around subject edges
  // For each subject pixel near removed pixels, slightly reduce key channel
  // This improves edges for chroma spills.
  const despillRadius = 2;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = y*w + x;
      if(subjectMask[idx] === 1){
        // check neighbor if any neighbor was removed (background) within small radius
        let nearBg = false;
        for(let ny=Math.max(0,y-despillRadius); ny<=Math.min(h-1,y+despillRadius) && !nearBg; ny++){
          for(let nx=Math.max(0,x-despillRadius); nx<=Math.min(w-1,x+despillRadius); nx++){
            if(subjectMask[ny*w + nx] === 0){ nearBg = true; break; }
          }
        }
        if(nearBg){
          const i = idx*4;
          if(key.label === 'green'){
            // reduce green slightly
            data[i+1] = Math.round(data[i+1] * 0.85);
          } else {
            data[i+2] = Math.round(data[i+2] * 0.85);
          }
        }
      }
    }
  }

  // Put alpha-modified image temporarily
  ctx.putImageData(imgData,0,0);

  // Create stroke mask by dilating subject mask
  const strokeMask = new Uint8ClampedArray(w*h); // 1 = stroke
  const radius = Math.max(1, Math.round(strokeWidth));
  // For speed, precompute offsets within radius
  const offsets = [];
  for(let dy=-radius; dy<=radius; dy++){
    for(let dx=-radius; dx<=radius; dx++){
      if(dx*dx + dy*dy <= radius*radius){
        offsets.push([dx,dy]);
      }
    }
  }
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = y*w + x;
      if(subjectMask[i] === 0){
        // if any neighbor within radius is subject, mark as stroke
        let hit = false;
        for(const [dx,dy] of offsets){
          const nx = x + dx, ny = y + dy;
          if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
          if(subjectMask[ny*w + nx] === 1){ hit = true; break; }
        }
        if(hit) strokeMask[i] = 1;
      }
    }
  }

  // Render stroke onto canvas: draw stroke color for strokeMask, then draw subject on top
  // We'll store current image as subjectImage to draw later
  const subjectCanvas = document.createElement('canvas');
  subjectCanvas.width = w; subjectCanvas.height = h;
  const sctx = subjectCanvas.getContext('2d');
  // Put the subject image (with transparent background) into subjectCanvas
  sctx.putImageData(imgData,0,0);

  // Now clear original and draw stroke
  ctx.clearRect(0,0,w,h);
  // Draw stroke pixel-by-pixel
  const strokeImg = ctx.createImageData(w,h);
  const scData = strokeImg.data;
  const strokeRGB = hexToRgb(strokeColor);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i = y*w + x;
      if(strokeMask[i]){
        const j = i*4;
        scData[j] = strokeRGB.r;
        scData[j+1] = strokeRGB.g;
        scData[j+2] = strokeRGB.b;
        scData[j+3] = 255;
      } else {
        const j = i*4;
        scData[j] = 0; scData[j+1] = 0; scData[j+2] = 0; scData[j+3] = 0;
      }
    }
  }
  ctx.putImageData(strokeImg,0,0);
  // Finally draw subject on top
  ctx.drawImage(subjectCanvas,0,0);
}

// helper hex->rgb
function hexToRgb(hex){
  const h = hex.replace('#','');
  const bigint = parseInt(h,16);
  if(h.length === 6){
    return {r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255};
  } else if(h.length === 3){
    return {r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16)};
  }
  return {r:0,g:0,b:0};
}

// ---- Render UI items ----
function renderItem(item){
  const el = document.createElement('div');
  el.className = 'card';
  el.id = 'item-' + item.id;

  const canvas = document.createElement('canvas');
  canvas.className = 'preview';
  canvas.width = Math.min(256, item.canvas.width);
  canvas.height = Math.min(256, item.canvas.height);
  // draw scaled preview with preserving transparency
  const pctx = canvas.getContext('2d');
  pctx.imageSmoothingEnabled = true;
  pctx.clearRect(0,0,canvas.width,canvas.height);
  pctx.drawImage(item.canvas, 0, 0, canvas.width, canvas.height);

  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = item.name;

  const actions = document.createElement('div');
  actions.className = 'actions';

  const dlBtn = document.createElement('button');
  dlBtn.className = 'btn small';
  dlBtn.textContent = 'Download PNG';
  dlBtn.addEventListener('click', ()=> {
    const url = URL.createObjectURL(item.blob);
    const a = document.createElement('a');
    a.href = url; a.download = item.name;
    document.body.appendChild(a); a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  const removeBtn = document.createElement('button');
  removeBtn.className = 'btn ghost small';
  removeBtn.textContent = 'Remove';
  removeBtn.addEventListener('click', ()=>{
    // remove from state and UI
    STATE.items = STATE.items.filter(i => i.id !== item.id);
    el.remove();
  });

  actions.appendChild(dlBtn);
  actions.appendChild(removeBtn);

  el.appendChild(canvas);
  el.appendChild(meta);
  el.appendChild(actions);
  grid.appendChild(el);
}

// ---- Clear all ----
clearAllBtn.addEventListener('click', ()=>{
  STATE.items = [];
  grid.innerHTML = '';
});

// ---- Zip download (JSZip) ----
downloadZipBtn.addEventListener('click', async ()=>{
  if(STATE.items.length === 0){ alert('No processed items to download.'); return; }
  // load JSZip dynamically
  if(typeof JSZip === 'undefined'){
    await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
  }
  const zip = new JSZip();
  const folder = zip.folder('chroma_stroke_export');
  // add each blob
  for(const item of STATE.items){
    // if blob already present, use it; if not, create from canvas
    if(item.blob){
      folder.file(item.name, item.blob);
    } else {
      const blob = await new Promise(res => item.canvas.toBlob(res, 'image/png'));
      folder.file(item.name, blob);
    }
  }
  const content = await zip.generateAsync({type:'blob'});
  const url = URL.createObjectURL(content);
  const a = document.createElement('a');
  a.href = url; a.download = 'chroma_stroke_export.zip';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

// dynamic script loader
function loadScript(src){
  return new Promise((resolve,reject)=>{
    const s = document.createElement('script');
    s.src = src; s.onload = resolve; s.onerror = reject;
    document.head.appendChild(s);
  });
}

// ---- Initialization helper: small sample image for quick test (optional) ----
// none; user will upload

</script>
</body>
</html>
