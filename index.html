<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaKey v4.4 (Eyedropper)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/dist/tailwind.min.css" rel="stylesheet">
    
    <style>
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .toast-enter { animation: slideInRight 0.3s ease-out; }
        .toast-exit { animation: slideOutRight 0.3s ease-in; }
        .fade-in { animation: fadeIn 0.2s ease-out; }
        
        .checkerboard {
            background-image: 
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #2a2a2a 75%), 
                linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        @media (max-width: 768px) {
            .mobile-drawer {
                transform: translateX(-100%);
                transition: transform 0.3s ease-in-out;
            }
            .mobile-drawer.open {
                transform: translateX(0);
            }
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #374151;
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ff006e;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
        }
        
        input[type="range"]::-moz-range-track {
            background: #374151;
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ff006e;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .processing .processing-overlay {
            display: flex !important;
        }
        
        .popover-menu {
            position: absolute;
            bottom: 100%;
            left: 0;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 100;
            display: none;
            flex-direction: column;
            min-width: 150px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        
        .popover-menu.active { 
            display: flex; 
        }
        
        .popover-item {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            cursor: pointer;
            color: #e5e7eb;
            border-bottom: 1px solid #374151;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            transition: all 0.15s;
        }
        
        .popover-item:last-child { 
            border-bottom: none; 
        }
        
        .popover-item:hover { 
            background: #ff006e;
            color: white;
        }
        
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }

        .eyedropper-icon {
            width: 14px;
            height: 14px;
            background: url('data:image/svg+xml;utf8,<svg fill="white" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17.66 11.2C17.43 10.9 17.15 10.64 16.89 10.38L13.62 7.11C13.36 6.85 13.1 6.57 12.8 6.34L14.07 5.07L12.03 3.03C11.77 2.77 11.36 2.77 11.1 3.03L3 11.13C2.73 11.39 2.73 11.81 3 12.07L5.03 14.11L3.92 15.22C3.38 15.77 3.38 16.65 3.92 17.2L6.8 20.08C7.35 20.63 8.23 20.63 8.78 20.08L9.89 18.97L11.93 21C12.19 21.27 12.61 21.27 12.87 21L20.97 12.9L17.66 11.2ZM8.07 19.37L5.2 16.5L6.31 15.39L9.18 18.26L8.07 19.37ZM12.16 18.8L7.9 14.54L13.84 8.6L18.1 12.86L12.16 18.8Z"/></svg>') no-repeat center center;
            background-size: contain;
            flex-shrink: 0;
        }
        
        .img-preview.picking-mode {
            cursor: crosshair;
            box-shadow: inset 0 0 0 3px #ff006e;
            position: relative;
        }
        
        .img-preview.picking-mode::after {
            content: "Click color to remove";
            position: absolute;
            bottom: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 0.75rem;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            pointer-events: none;
            white-space: nowrap;
            font-weight: 500;
        }

        .img-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none;
            border: 1px solid #555;
        }
    </style>
</head>
<body class="bg-gray-950 text-gray-100 font-sans antialiased">

    <!-- Toast Container -->
    <div id="toastContainer" class="fixed z-50 flex flex-col gap-2 pointer-events-none" 
         style="bottom: 1rem; right: 1rem; max-width: 400px;">
    </div>

    <!-- Mobile Menu Toggle -->
    <button id="mobileMenuToggle" class="md:hidden fixed top-4 left-4 z-50 bg-gray-800 hover:bg-gray-700 text-white p-3 rounded-lg shadow-lg transition-colors">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
    </button>

    <!-- Header -->
    <header class="bg-gray-900 border-b border-gray-800 sticky top-0 z-40">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-gradient-to-br from-pink-500 to-purple-600 rounded-lg flex items-center justify-center">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
                        </svg>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold text-white">Chroma Tool</h1>
                        <p class="text-xs text-gray-400">v4.4 (Eyedropper)</p>
                    </div>
                </div>
                <div id="statusText" class="hidden md:block text-sm text-gray-400">
                    0 images loaded
                </div>
            </div>
        </div>
    </header>

    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div class="flex flex-col lg:flex-row gap-6">
            
            <!-- Controls Panel -->
            <aside id="controlsPanel" class="lg:w-80 mobile-drawer md:relative md:transform-none fixed inset-y-0 left-0 z-40 bg-gray-900 md:bg-transparent">
                <div class="h-full overflow-y-auto p-4 md:p-0">
                    <div class="bg-gray-900 rounded-xl shadow-2xl border border-gray-800 lg:sticky lg:top-24">
                        <div class="p-6 space-y-6">
                            
                            <!-- Upload Section -->
                            <div>
                                <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-3">Upload</h3>
                                <div id="dropzone" class="border-2 border-dashed border-gray-700 hover:border-pink-500 rounded-lg p-8 text-center cursor-pointer transition-all group bg-gray-800/50 hover:bg-gray-800">
                                    <svg class="w-12 h-12 mx-auto mb-3 text-gray-600 group-hover:text-pink-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                    </svg>
                                    <p class="text-sm text-gray-400 group-hover:text-gray-300">Drag & Drop Images<br>or Click to Browse</p>
                                    <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                                </div>
                            </div>

                            <!-- Export Settings -->
                            <div>
                                <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-3">Export Size</h3>
                                <select id="exportSize" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-4 py-2.5 text-white focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent transition-all">
                                    <option value="512">512 x 512</option>
                                    <option value="256">256 x 256</option>
                                    <option value="128">128 x 128</option>
                                    <option value="64">64 x 64</option>
                                    <option value="original">Original (Disable Norm)</option>
                                </select>
                            </div>
                            
                            <div class="flex items-center justify-between bg-gray-800 rounded-lg px-4 py-3 border border-gray-700">
                                <label for="normalizeObject" class="text-sm text-gray-300 cursor-pointer flex-1">Normalize / Center Object</label>
                                <input type="checkbox" id="normalizeObject" checked class="w-5 h-5 text-pink-500 bg-gray-700 border-gray-600 rounded focus:ring-2 focus:ring-pink-500 cursor-pointer">
                            </div>

                            <hr class="border-gray-800">

                            <!-- Tolerance -->
                            <div>
                                <label class="block text-sm text-gray-300 mb-2">
                                    Tolerance 
                                    <span id="tolVal" class="float-right text-pink-500 font-semibold">50</span>
                                </label>
                                <input type="range" id="tolerance" min="1" max="150" value="50" class="w-full h-2 bg-gray-800 rounded-lg appearance-none cursor-pointer">
                            </div>

                            <hr class="border-gray-800">

                            <!-- Stroke Settings -->
                            <div>
                                <h3 class="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-3">Stroke</h3>
                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-sm text-gray-300 mb-2">
                                            Width (px)
                                            <span id="strokeVal" class="float-right text-pink-500 font-semibold">10</span>
                                        </label>
                                        <input type="range" id="strokeWidth" min="0" max="50" value="10" class="w-full h-2 bg-gray-800 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label class="block text-sm text-gray-300 mb-2">Stroke Color</label>
                                        <input type="color" id="strokeColor" value="#000000" class="w-full h-12 bg-gray-800 border border-gray-700 rounded-lg cursor-pointer">
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </aside>

            <!-- Main Content Area -->
            <main class="flex-1 min-w-0">
                
                <!-- Batch Actions Bar -->
                <div class="bg-gray-900 rounded-xl shadow-lg border border-gray-800 p-4 mb-6 sticky top-24 z-30">
                    <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
                        <div class="flex items-center gap-2">
                            <span id="statusTextMobile" class="text-sm text-gray-400">0 images loaded</span>
                        </div>
                        <div class="flex gap-2 w-full sm:w-auto">
                            <button id="downloadBatchBtn" disabled class="flex-1 sm:flex-none bg-gradient-to-r from-pink-600 to-purple-600 hover:from-pink-700 hover:to-purple-700 disabled:from-gray-700 disabled:to-gray-700 text-white px-4 py-2 rounded-lg font-medium transition-all disabled:cursor-not-allowed disabled:opacity-50 text-sm uppercase tracking-wide">
                                Download All (Files)
                            </button>
                            <button id="downloadZipBtn" disabled class="flex-1 sm:flex-none bg-gradient-to-r from-pink-600 to-purple-600 hover:from-pink-700 hover:to-purple-700 disabled:from-gray-700 disabled:to-gray-700 text-white px-4 py-2 rounded-lg font-medium transition-all disabled:cursor-not-allowed disabled:opacity-50 text-sm uppercase tracking-wide">
                                Download All (ZIP)
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Results Grid -->
                <div id="resultsGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-20">
                    <!-- Image cards will be inserted here -->
                </div>

            </main>
        </div>
    </div>

<script>
    // ============ TOAST SYSTEM (NEW UI FEATURE) ============
    const Toast = {
        container: null,
        
        init() {
            this.container = document.getElementById('toastContainer');
            if (window.innerWidth < 768) {
                this.container.style.left = '50%';
                this.container.style.right = 'auto';
                this.container.style.transform = 'translateX(-50%)';
                this.container.style.bottom = '1rem';
            }
        },
        
        show(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast-enter pointer-events-auto';
            
            const colors = {
                success: 'bg-green-600',
                error: 'bg-red-600',
                warning: 'bg-yellow-600',
                info: 'bg-blue-600',
            };
            
            const icons = {
                success: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>',
                error: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>',
                warning: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>',
                info: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>',
            };
            
            toast.innerHTML = `
                <div class="${colors[type]} text-white px-4 py-3 rounded-lg shadow-2xl flex items-center gap-3 min-w-[280px] max-w-[400px]" role="${type === 'error' ? 'alert' : 'status'}">
                    <svg class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        ${icons[type]}
                    </svg>
                    <span class="flex-1 text-sm font-medium">${message}</span>
                    <button class="toast-close hover:bg-white/20 rounded p-1 transition-colors">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            `;
            
            this.container.appendChild(toast);
            
            const closeBtn = toast.querySelector('.toast-close');
            
            const remove = () => {
                toast.classList.remove('toast-enter');
                toast.classList.add('toast-exit');
                setTimeout(() => toast.remove(), 300);
            };
            
            closeBtn.addEventListener('click', remove);
            
            if (duration > 0) {
                setTimeout(remove, duration);
            }
        }
    };

    Toast.init();

    // ============ MOBILE MENU (NEW UI FEATURE) ============
    document.getElementById('mobileMenuToggle').addEventListener('click', () => {
        document.getElementById('controlsPanel').classList.toggle('open');
    });

    document.addEventListener('click', (e) => {
        const panel = document.getElementById('controlsPanel');
        const toggle = document.getElementById('mobileMenuToggle');
        if (window.innerWidth < 768 && !panel.contains(e.target) && !toggle.contains(e.target)) {
            panel.classList.remove('open');
        }
    });

    // ============ ORIGINAL APP CODE (UNCHANGED) ============
    const state = {
        files: [], 
        settings: { 
            tolerance: 50, 
            strokeWidth: 10, 
            strokeColor: '#000000',
            exportSize: '512',
            normalizeObject: true 
        },
        activeMenuFileId: null
    };

    const els = {
        dropzone: document.getElementById('dropzone'),
        fileInput: document.getElementById('fileInput'),
        exportSize: document.getElementById('exportSize'),
        normalizeObject: document.getElementById('normalizeObject'),
        tolerance: document.getElementById('tolerance'),
        strokeWidth: document.getElementById('strokeWidth'),
        strokeColor: document.getElementById('strokeColor'),
        tolVal: document.getElementById('tolVal'),
        strokeVal: document.getElementById('strokeVal'),
        resultsGrid: document.getElementById('resultsGrid'),
        downloadZipBtn: document.getElementById('downloadZipBtn'),
        downloadBatchBtn: document.getElementById('downloadBatchBtn'),
        statusText: document.getElementById('statusText'),
        statusTextMobile: document.getElementById('statusTextMobile')
    };

    let processTimeout;

    window.addEventListener('DOMContentLoaded', () => {
        loadSettings();
        bindEvents();
    });

    window.addEventListener('click', (e) => {
        if (!e.target.closest('.tag') && !e.target.closest('.popover-menu')) {
            closeAllMenus();
        }
    });

    function closeAllMenus() {
        document.querySelectorAll('.popover-menu').forEach(el => el.classList.remove('active'));
        state.activeMenuFileId = null;
    }

    function loadSettings() {
        const saved = localStorage.getItem('chromaToolSettings_v4.4');
        if (saved) {
            state.settings = { ...state.settings, ...JSON.parse(saved) };
            els.tolerance.value = state.settings.tolerance;
            els.strokeWidth.value = state.settings.strokeWidth;
            els.strokeColor.value = state.settings.strokeColor;
            els.exportSize.value = state.settings.exportSize;
            els.normalizeObject.checked = state.settings.normalizeObject;
            els.tolVal.innerText = state.settings.tolerance;
            els.strokeVal.innerText = state.settings.strokeWidth;
        }
    }

    function saveSettings() {
        localStorage.setItem('chromaToolSettings_v4.4', JSON.stringify(state.settings));
    }

    function bindEvents() {
        els.dropzone.addEventListener('click', () => els.fileInput.click());
        els.dropzone.addEventListener('dragover', (e) => { e.preventDefault(); els.dropzone.classList.add('dragover'); });
        els.dropzone.addEventListener('dragleave', () => els.dropzone.classList.remove('dragover'));
        els.dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            els.dropzone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        els.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        const updateHandler = () => {
            state.settings.tolerance = parseInt(els.tolerance.value);
            state.settings.strokeWidth = parseInt(els.strokeWidth.value);
            state.settings.strokeColor = els.strokeColor.value;
            state.settings.exportSize = els.exportSize.value;
            state.settings.normalizeObject = els.normalizeObject.checked;
            
            els.tolVal.innerText = state.settings.tolerance;
            els.strokeVal.innerText = state.settings.strokeWidth;
            
            saveSettings();
            triggerBatchProcess();
        };

        els.tolerance.addEventListener('input', updateHandler);
        els.strokeWidth.addEventListener('input', updateHandler);
        els.strokeColor.addEventListener('input', updateHandler);
        els.exportSize.addEventListener('change', updateHandler);
        els.normalizeObject.addEventListener('change', updateHandler); 

        els.downloadZipBtn.addEventListener('click', downloadAllZip);
        els.downloadBatchBtn.addEventListener('click', downloadAllBatch);
    }

    function handleFiles(fileList) {
        Array.from(fileList).forEach(file => {
            if (!file.type.startsWith('image/')) return;
            const id = Date.now() + Math.random().toString(36).substr(2, 9);
            const card = createResultCard(id, file.name);
            els.resultsGrid.appendChild(card);

            const fileData = { 
                id, 
                originalFile: file, 
                processedBlob: null, 
                element: card,
                manualMode: null, 
                customHex: '#ff0000'
            };

            const tag = card.querySelector('.tag');
            tag.addEventListener('click', (e) => toggleMenu(e, fileData));

            state.files.push(fileData);
            processImage(fileData);
        });
        updateStatus();
    }

    function updateStatus() {
        const text = `${state.files.length} image(s)`;
        els.statusText.innerText = text;
        els.statusTextMobile.innerText = text;
        const isDisabled = state.files.length === 0;
        els.downloadZipBtn.disabled = isDisabled;
        els.downloadBatchBtn.disabled = isDisabled;
    }

    function triggerBatchProcess() {
        clearTimeout(processTimeout);
        processTimeout = setTimeout(() => {
            state.files.forEach(processImage);
        }, 300);
    }

    function toggleMenu(e, fileData) {
        e.stopPropagation();
        const existingMenu = fileData.element.querySelector('.popover-menu');
        
        if (existingMenu.classList.contains('active')) {
            existingMenu.classList.remove('active');
            state.activeMenuFileId = null;
            return;
        }
        closeAllMenus();

        existingMenu.innerHTML = `
            <div class="popover-item" data-mode="green"><div class="color-dot" style="background:#0f0"></div> Green</div>
            <div class="popover-item" data-mode="blue"><div class="color-dot" style="background:#00f"></div> Blue</div>
            <div class="popover-item" data-mode="white"><div class="color-dot" style="background:#fff"></div> White</div>
            <div class="popover-item" data-mode="black"><div class="color-dot" style="background:#000"></div> Black</div>
            <div class="popover-item" data-mode="picker"><div class="eyedropper-icon"></div> Eyedropper</div>
        `;

        existingMenu.querySelectorAll('.popover-item').forEach(item => {
            item.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const mode = item.dataset.mode;
                
                if (mode === 'picker') {
                    activateEyedropper(fileData);
                    closeAllMenus();
                } else {
                    fileData.manualMode = mode;
                    closeAllMenus();
                    processImage(fileData);
                }
            });
        });

        existingMenu.classList.add('active');
        state.activeMenuFileId = fileData.id;
    }

    function activateEyedropper(fileData) {
        const previewDiv = fileData.element.querySelector('.img-preview');
        const imgEl = previewDiv.querySelector('img');

        imgEl.src = URL.createObjectURL(fileData.originalFile);
        
        previewDiv.classList.add('picking-mode');

        const clickHandler = (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            previewDiv.classList.remove('picking-mode');
            
            const rect = imgEl.getBoundingClientRect();
            
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                const containerRatio = rect.width / rect.height;
                const imgRatio = img.width / img.height;
                
                let renderWidth, renderHeight, renderLeft, renderTop;

                if (imgRatio > containerRatio) {
                    renderWidth = rect.width;
                    renderHeight = rect.width / imgRatio;
                    renderLeft = 0;
                    renderTop = (rect.height - renderHeight) / 2;
                } else {
                    renderHeight = rect.height;
                    renderWidth = rect.height * imgRatio;
                    renderTop = 0;
                    renderLeft = (rect.width - renderWidth) / 2;
                }

                const clientX = e.clientX - rect.left;
                const clientY = e.clientY - rect.top;

                const relativeX = clientX - renderLeft;
                const relativeY = clientY - renderTop;

                if (relativeX >= 0 && relativeX <= renderWidth && relativeY >= 0 && relativeY <= renderHeight) {
                    const trueX = Math.floor((relativeX / renderWidth) * img.width);
                    const trueY = Math.floor((relativeY / renderHeight) * img.height);
                    
                    const p = ctx.getImageData(trueX, trueY, 1, 1).data;
                    const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                    
                    fileData.manualMode = 'custom';
                    fileData.customHex = hex;
                    
                    processImage(fileData);
                } else {
                    processImage(fileData);
                }
            };
            img.src = URL.createObjectURL(fileData.originalFile);
        };

        previewDiv.addEventListener('click', clickHandler, { once: true });
    }

    function processImage(fileData) {
        const card = fileData.element;
        card.classList.add('processing');

        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');

            ctx.drawImage(img, 0, 0);
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            let mode = 'green';
            let customRGB = null;

            if (fileData.manualMode) {
                mode = fileData.manualMode;
                if (mode === 'custom' && fileData.customHex) {
                    const r = parseInt(fileData.customHex.substr(1,2), 16);
                    const g = parseInt(fileData.customHex.substr(3,2), 16);
                    const b = parseInt(fileData.customHex.substr(5,2), 16);
                    customRGB = { r, g, b };
                }
            } else {
                let gScore = 0, bScore = 0, blackScore = 0, whiteScore = 0;
                for (let i = 0; i < data.length; i+=32) { 
                    if (i < width*4 || i > (height-1)*width*4 || i % (width*4) === 0) {
                        const r = data[i], g = data[i+1], b = data[i+2];
                        const bright = (r+g+b)/3;
                        if (bright < 40) blackScore++; 
                        else if (bright > 230) whiteScore++; 
                        else if (g > r && g > b) gScore++; 
                        else if (b > r && b > g) bScore++; 
                    }
                }
                let maxScore = Math.max(gScore, bScore, blackScore, whiteScore);
                if (maxScore === bScore) mode = 'blue';
                else if (maxScore === blackScore) mode = 'black';
                else if (maxScore === whiteScore) mode = 'white';
            }

            const tag = card.querySelector('.tag');
            if (mode === 'custom' && customRGB) {
                tag.innerText = 'Custom';
                tag.style.background = fileData.customHex;
                const yiq = ((customRGB.r*299)+(customRGB.g*587)+(customRGB.b*114))/1000;
                tag.style.color = (yiq >= 128) ? 'black' : 'white';
            } else {
                tag.innerText = mode;
                tag.style.background = (mode === 'green') ? '#90EE90' : (mode === 'blue') ? '#ADD8E6' : (mode === 'white') ? '#eee' : '#222';
                tag.style.color = (mode === 'white' || mode === 'green' || mode === 'blue') ? '#000' : '#fff';
            }

            const tol = state.settings.tolerance;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                let isBackground = false;

                if (mode === 'green') { 
                    if (g > r + tol && g > b + tol) isBackground = true; 
                } 
                else if (mode === 'blue') { 
                    if (b > r + tol && b > g + tol) isBackground = true; 
                }
                else if (mode === 'black') { 
                    if (r < tol && g < tol && b < tol) isBackground = true; 
                }
                else if (mode === 'white') { 
                    if (r > (255-tol) && g > (255-tol) && b > (255-tol)) isBackground = true; 
                }
                else if (mode === 'custom' && customRGB) {
                    const dist = Math.sqrt(
                        Math.pow(r - customRGB.r, 2) + 
                        Math.pow(g - customRGB.g, 2) + 
                        Math.pow(b - customRGB.b, 2)
                    );
                    if (dist < tol * 1.5) isBackground = true; 
                }

                if (isBackground) data[i+3] = 0; 
            }

            removeIslands(data, width, height, 100);

            if (state.settings.strokeWidth > 0) {
                applyStroke(data, width, height, state.settings.strokeWidth, state.settings.strokeColor);
            }

            ctx.putImageData(imageData, 0, 0);

            let finalCanvas = document.createElement('canvas');
            let exportSize = parseInt(state.settings.exportSize);
            
            if (isNaN(exportSize)) exportSize = Math.max(width, height); 
            
            finalCanvas.width = exportSize;
            finalCanvas.height = exportSize;
            const fCtx = finalCanvas.getContext('2d');
            fCtx.imageSmoothingEnabled = true;
            fCtx.imageSmoothingQuality = 'high';

            if (state.settings.normalizeObject) {
                const bounds = getContentBounds(data, width, height);
                
                if (bounds.w > 0 && bounds.h > 0) {
                    const padding = exportSize * 0.1; 
                    const availableW = exportSize - (padding * 2);
                    const availableH = exportSize - (padding * 2);
                    const scale = Math.min(availableW / bounds.w, availableH / bounds.h);
                    
                    const renderW = bounds.w * scale;
                    const renderH = bounds.h * scale;
                    const renderX = (exportSize - renderW) / 2;
                    const renderY = (exportSize - renderH) / 2;

                    fCtx.drawImage(
                        canvas, 
                        bounds.x, bounds.y, bounds.w, bounds.h, 
                        renderX, renderY, renderW, renderH      
                    );
                } else {
                    fCtx.clearRect(0,0, exportSize, exportSize);
                }
            } else {
                if (state.settings.exportSize === 'original') {
                    finalCanvas = canvas; 
                } else {
                    fCtx.drawImage(canvas, 0, 0, exportSize, exportSize);
                }
            }

            finalCanvas.toBlob((blob) => {
                fileData.processedBlob = blob;
                const url = URL.createObjectURL(blob);
                const prevContainer = card.querySelector('.img-preview');
                prevContainer.innerHTML = '';
                const resImg = new Image();
                resImg.src = url;
                prevContainer.appendChild(resImg);

                card.querySelector('.dl-btn').onclick = () => {
                    saveAs(blob, 'processed_' + fileData.originalFile.name.replace(/\.[^/.]+$/, "") + ".png");
                };
                card.classList.remove('processing');
            }, 'image/png');
        };
        img.src = URL.createObjectURL(fileData.originalFile);
    }

    function getContentBounds(data, w, h) {
        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const alpha = data[(y * w + x) * 4 + 3];
                if (alpha > 0) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return { x:0, y:0, w:0, h:0 };
        return { x: minX, y: minY, w: (maxX - minX + 1), h: (maxY - minY + 1) };
    }

    function removeIslands(data, width, height, minSize) {
        const visited = new Uint8Array(width * height);
        const stack = [];
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                if (data[idx * 4 + 3] > 0 && visited[idx] === 0) {
                    stack.push(idx);
                    visited[idx] = 1;
                    const component = [idx];
                    while(stack.length > 0) {
                        const curr = stack.pop();
                        const neighbors = [1, -1, width, -width];
                        for (let offset of neighbors) {
                             const nIdx = curr + offset;
                             if (nIdx >= 0 && nIdx < width*height && visited[nIdx]===0) {
                                 if (data[nIdx*4+3] > 0) {
                                     visited[nIdx] = 1;
                                     stack.push(nIdx);
                                     component.push(nIdx);
                                 }
                             }
                        }
                    }
                    if (component.length < minSize) {
                        for (const i of component) data[i * 4 + 3] = 0;
                    }
                }
            }
        }
    }

    function applyStroke(data, width, height, strokeWidth, hexColor) {
        const INF = 1e9;
        const grid = new Float32Array(width * height);
        const sr = parseInt(hexColor.substr(1,2), 16);
        const sg = parseInt(hexColor.substr(3,2), 16);
        const sb = parseInt(hexColor.substr(5,2), 16);

        for (let i = 0; i < width * height; i++) grid[i] = (data[i * 4 + 3] > 0) ? 0 : INF;
        for (let i = 0; i < width*height; i++) {
            if (grid[i] > 0) {
                const x = i % width;
                const y = Math.floor(i / width);
                let minD = grid[i];
                if (x > 0) minD = Math.min(minD, grid[i-1] + 1);
                if (y > 0) minD = Math.min(minD, grid[i-width] + 1);
                if (x > 0 && y > 0) minD = Math.min(minD, grid[i-width-1] + 1.414);
                if (x < width-1 && y > 0) minD = Math.min(minD, grid[i-width+1] + 1.414);
                grid[i] = minD;
            }
        }
        for (let i = width*height - 1; i >= 0; i--) {
            if (grid[i] > 0) {
                const x = i % width;
                const y = Math.floor(i / width);
                let minD = grid[i];
                if (x < width - 1) minD = Math.min(minD, grid[i+1] + 1);
                if (y < height - 1) minD = Math.min(minD, grid[i+width] + 1);
                if (x < width - 1 && y < height - 1) minD = Math.min(minD, grid[i+width+1] + 1.414);
                if (x > 0 && y < height - 1) minD = Math.min(minD, grid[i+width-1] + 1.414);
                grid[i] = minD;
            }
        }
        for (let i = 0; i < width * height; i++) {
            const dist = grid[i];
            if (dist > 0 && dist <= strokeWidth + 0.5) {
                const pIdx = i * 4;
                let alpha = 255;
                if (dist > strokeWidth - 0.5) alpha = 255 * (1 - (dist - (strokeWidth - 0.5)));
                data[pIdx] = sr; data[pIdx+1] = sg; data[pIdx+2] = sb; data[pIdx+3] = alpha;
            }
        }
    }

    function createResultCard(id, filename) {
        const div = document.createElement('div');
        div.className = 'image-card bg-gray-900 rounded-xl shadow-lg border border-gray-800 overflow-hidden transition-all hover:shadow-2xl hover:shadow-pink-500/10 hover:-translate-y-1 fade-in';
        div.innerHTML = `
            <div class="img-preview checkerboard h-48 flex items-center justify-center p-3 relative">
                <div class="text-gray-600 text-sm">Waiting...</div>
            </div>
            <div class="processing-overlay absolute inset-0 bg-black/80 backdrop-blur-sm flex-col hidden items-center justify-center">
                <svg class="animate-spin h-8 w-8 text-pink-500 mb-2" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-white text-sm font-medium">Processing...</span>
            </div>
            <div class="card-actions p-3 bg-gray-800/50 flex items-center justify-between gap-2 relative">
                <div class="flex items-center gap-2 flex-1 min-w-0">
                    <span class="tag text-[10px] px-2 py-1 rounded bg-gray-700 text-gray-300 font-semibold uppercase tracking-wide cursor-pointer hover:bg-gray-600 transition-colors" title="Click to change chroma key">...</span>
                    <div class="popover-menu"></div>
                    <div class="text-xs text-gray-400 truncate flex-1">${filename}</div>
                </div>
                <button class="dl-btn p-2 hover:bg-gray-700 rounded-lg transition-colors text-gray-400 hover:text-white" title="Download">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                    </svg>
                </button>
            </div>
        `;
        return div;
    }

    function downloadAllZip() {
        const zip = new JSZip();
        const imgFolder = zip.folder("processed_images");
        let count = 0;
        state.files.forEach(file => {
            if (file.processedBlob) {
                imgFolder.file('processed_' + file.originalFile.name.replace(/\.[^/.]+$/, "") + ".png", file.processedBlob);
                count++;
            }
        });
        if (count > 0) {
            els.downloadZipBtn.disabled = true; 
            imgFolder.generateAsync({type:"blob"}).then(content => {
                saveAs(content, "chroma_key_results.zip");
                els.downloadZipBtn.disabled = false; 
            });
        }
    }

    function downloadAllBatch() {
        let downloadedCount = 0;
        els.downloadBatchBtn.disabled = true; 
        const total = state.files.filter(f => f.processedBlob).length;
        if(total === 0) { els.downloadBatchBtn.disabled = false; return; }

        state.files.forEach((file, index) => {
            if (file.processedBlob) {
                setTimeout(() => {
                    saveAs(file.processedBlob, 'processed_' + file.originalFile.name.replace(/\.[^/.]+$/, "") + ".png");
                    downloadedCount++;
                    if (downloadedCount === total) els.downloadBatchBtn.disabled = false;
                }, index * 250); 
            }
        });
    }
</script>

</body>
</html>
